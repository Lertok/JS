// 1. Почему код дает именно такие результаты?

var a = 1, b = 1, c, d;
c = ++a; alert(c); // 2 переменная а сначало увеличивается на 1, а затем присваевается переменной с
d = b++; alert(d); // 1 переменная b сначала присваевается d, затем увеличивается на 1
c = (2 + ++a); alert(c); // 5 переменная а увеличивается на 1 уже второй раз и равняется 3, 2 + 3 = 5
d = (2 + b++); alert(d); // 4 переменная b уже была увеличена на 1 и равняется 2, в данной записи она сначала пребавляется к 2, а затем увеличивается еще на 1, 2 + 2 = 4
alert(a); // 3 переменная увеличивалась 2 раза на 1 
alert(b); // 3 переменная увеличивалась 2 раза на 1

// 2. Чему будет равен x?
var a = 2;
var x = 1 + (a *= 2);
// х = 5, так как переменная а сначала умножается на 2 (2*2=4), затем пребавляется к 1

// 3. Объявить две целочисленные переменные — a и b и задать им произвольные начальные значения. Затем написать скрипт, который работает по следующему принципу:
// o если a и b положительные, вывести их разность;
// o если а и b отрицательные, вывести их произведение;
// o если а и b разных знаков, вывести их сумму;
// Ноль можно считать положительным числом.
let a = 4;
let b = 3;

if (a >= 0 && b >= 0)
    console.log(a - b);
else if (a < 0 && b < 0)
    console.log(a * b);
else
    console.log(a + b);

// 4. Присвоить переменной а значение в промежутке [0..15]. С помощью оператора switch организовать вывод чисел от a до 15.
let a = 11;

switch (a) {
    case 0:
        console.log(0)
    case 1:
        console.log(1)
    case 2:
        console.log(2)
    case 3:
        console.log(3)
    case 4:
        console.log(4)
    case 5:
        console.log(5)
    case 6:
        console.log(6)
    case 7:
        console.log(7)
    case 8:
        console.log(8)
    case 9:
        console.log(9)
    case 10:
        console.log(10)
    case 11:
        console.log(11)
    case 12:
        console.log(12)
    case 13:
        console.log(13)
    case 14:
        console.log(14)
    case 15:
        console.log(15)
        break;
}

// 5. Реализовать четыре основные арифметические операции в виде функций с двумя параметрами. Обязательно использовать оператор return.
function sum(a, b) {
    c = a + b;
    return c;
}

console.log(sum(2, 7))

function dif(a, b) {
    c = a - b;
    return c;
}

console.log(dif(2, 7))

function mult(a, b) {
    c = a * b;
    return c;
}

console.log(mult(2, 7))

function div(a, b) {
    c = a / b;
    return c;
}

console.log(div(2, 7))

// 6. Реализовать функцию с тремя параметрами: function mathOperation(arg1, arg2, operation),
// где arg1, arg2 — значения аргументов, operation — строка с названием операции. В
// зависимости от переданного значения выполнить одну из арифметических операций
// (использовать функции из пункта 5) и вернуть полученное значение (применить switch).
function math(a, b, oper) {
    switch (oper) {
        case '+':
            return sum(a, b);
        case '-':
            return dif(a, b);
        case '*':
            return mult(a, b);
        case '/':
            return div(a, b);
    }
}

console.log(math(5, 5, '+'))

// 7. * Сравнить null и 0. Объяснить результат.
c = null != 0; // true
console.log(c)
b = null == 0; // false
console.log(b)
// как я понял null обозначает отсутстви какого-либо объекта, а 0 это числовое значение и поидее не сравнимо. Дополнительно нашел материал про:
null > 0;     // false
null == 0;    // false
null >= 0;    // true
// тут я читал-читал и честно говоря запутался :) Понял что в случае null >= 0 - java проверяет одно значение null < 0 false следовательно утверждение null >= 0 true :)

// 8. * С помощью рекурсии организовать функцию возведения числа в степень. Формат: function
// power(val, pow), где val — заданное число, pow –— степень.

function power(val, pow) {
    if (pow == 1) {
        return val;
    } else {
        return val * power(val, pow - 1);
    }
}

console.log(power(2, 4))

// я вроде сделал почитав материал в интернете, но не совсем понимаю как функция понимает что ей нужно умножать 2 на 2 и не принимать во внимание второй аргумен (степень), но понимаю что она это будет делать такое количество раз пока pow не будет равна заданному условию paw = 1